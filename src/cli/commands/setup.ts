import { Command } from "commander";
import * as fs from "fs";
import * as path from "path";
import * as readline from "readline";

interface SetupAnswers {
  securityEmail: string;
  maintainers: string;
  projectDescription: string;
  licenseType: string;
}

export const setupCommand = new Command("setup")
  .description("Interactive setup to customize generated files")
  .action(async () => {
    try {
      console.log("\nüîß RepoForge Setup - Customize Your Repository\n");
      console.log(
        "This will help you fill in the blanks in generated files.\n"
      );

      const answers = await promptUser();

      console.log("\nüìù Updating files...\n");

      // Update SECURITY.md
      updateSecurityFile(answers.securityEmail);
      console.log("‚úì Updated SECURITY.md with contact email");

      // Update CODEOWNERS
      updateCodeOwnersFile(answers.maintainers);
      console.log("‚úì Updated .github/CODEOWNERS with maintainers");

      // Update package.json
      updatePackageJson(answers.projectDescription);
      console.log("‚úì Updated package.json with description");

      // Update README
      updateReadme(answers.projectDescription, answers.licenseType);
      console.log("‚úì Updated README.md");

      console.log("\n‚úÖ Setup complete!\n");
      console.log("Next steps:");
      console.log("  1. Review the updated files");
      console.log("  2. Run: repoctl validate");
      console.log("  3. Commit with: git add . && git commit -m 'repoforge: setup'");
    } catch (error) {
      console.error("‚ùå Error:", error instanceof Error ? error.message : error);
      process.exit(1);
    }
  });

async function promptUser(): Promise<SetupAnswers> {
  const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout,
  });

  return new Promise((resolve) => {
    const answers: SetupAnswers = {
      securityEmail: "",
      maintainers: "",
      projectDescription: "",
      licenseType: "MIT",
    };

    const askSecurityEmail = () => {
      rl.question(
        "üîí Security contact email (for vulnerability reports): ",
        (answer) => {
          answers.securityEmail = answer || "security@example.com";
          askMaintainers();
        }
      );
    };

    const askMaintainers = () => {
      rl.question(
        "üë• GitHub usernames of maintainers (comma-separated): ",
        (answer) => {
          answers.maintainers = answer || "@maintainers";
          askDescription();
        }
      );
    };

    const askDescription = () => {
      rl.question("üìñ Project description: ", (answer) => {
        answers.projectDescription =
          answer || "A TypeScript project managed by RepoForge";
        askLicense();
      });
    };

    const askLicense = () => {
      rl.question("üìÑ License type (MIT/Apache-2.0/GPL-3.0): ", (answer) => {
        answers.licenseType = answer || "MIT";
        rl.close();
        resolve(answers);
      });
    };

    askSecurityEmail();
  });
}

function updateSecurityFile(email: string): void {
  const securityPath = path.join(process.cwd(), "SECURITY.md");
  let content = fs.readFileSync(securityPath, "utf-8");

  content = content.replace(
    /\*\*\[ADD YOUR SECURITY CONTACT\]\*\*/g,
    `**${email}**`
  );

  fs.writeFileSync(securityPath, content, "utf-8");
}

function updateCodeOwnersFile(maintainers: string): void {
  const codeownersPath = path.join(process.cwd(), ".github", "CODEOWNERS");
  const maintainerList = maintainers
    .split(",")
    .map((m) => m.trim())
    .join(" ");

  const content = `# CODEOWNERS
# See: https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners

# Default owners
* ${maintainerList}

# Assign specific paths to team members
# /src/  @team-name
# .github/workflows/ @devops-team
`;

  fs.writeFileSync(codeownersPath, content, "utf-8");
}

function updatePackageJson(description: string): void {
  const pkgPath = path.join(process.cwd(), "package.json");
  const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf-8"));

  pkg.description = description;

  fs.writeFileSync(pkgPath, JSON.stringify(pkg, null, 2), "utf-8");
}

function updateReadme(description: string, license: string): void {
  const readmePath = path.join(process.cwd(), "README.md");
  let content = fs.readFileSync(readmePath, "utf-8");

  // Replace first occurrence of generic description
  content = content.replace(
    /> Automatically generated by \[RepoForge\]/,
    `> ${description}`
  );

  // Update license section
  content = content.replace(/## License\n\nMIT/, `## License\n\n${license}`);

  fs.writeFileSync(readmePath, content, "utf-8");
}
